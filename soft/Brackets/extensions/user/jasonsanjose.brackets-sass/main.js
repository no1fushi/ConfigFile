eval('/*\n * Copyright (c) 2015 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n */\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4 */\n/*global define: true, $: true, brackets: true*/\n\ndefine(\'StatusBarUtil\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\n    "use strict";\n    \n    var StringUtils     = brackets.getModule("utils/StringUtils"),\n        StatusBar       = brackets.getModule("widgets/StatusBar");\n    \n    var STATUS_INDICATOR_ID = "sass-status-indicator";\n\n    var StatusBarUtil = {\n        \n        $statusIndicator: null,\n        \n        showBusyStatus: function (statusText) {\n            StatusBar.showBusyIndicator();\n            if (!this.$statusIndicator) {\n                this.$statusIndicator = $("<div/>");\n                StatusBar.addIndicator(STATUS_INDICATOR_ID, this.$statusIndicator, false);\n            }\n            this.$statusIndicator.text(statusText);\n            StatusBar.updateIndicator(STATUS_INDICATOR_ID, true);\n        },\n        hideBusyStatus: function () {\n            StatusBar.hideBusyIndicator();\n            StatusBar.updateIndicator(STATUS_INDICATOR_ID, false);\n        }\n        \n\n    };\n\n    return StatusBarUtil;\n});\n\n//# sourceURL=/StatusBarUtil.js'),eval('/*\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n */\n/*jslint nomen:true, vars:true, regexp:true, plusplus:true*/\n/*global window, console, define, brackets, $, PathUtils*/\n\ndefine(\'Compiler\',[\'require\',\'exports\',\'module\',\'StatusBarUtil\'],function (require, exports, module) {\n    "use strict";\n    \n    var StatusBarUtil = require("StatusBarUtil");\n    \n    // Load commonly used modules from Brackets\n    var _                   = brackets.getModule("thirdparty/lodash"),\n        CodeInspection      = brackets.getModule("language/CodeInspection"),\n        ExtensionUtils      = brackets.getModule("utils/ExtensionUtils"),\n        FileUtils           = brackets.getModule("file/FileUtils"),\n        FileSystem          = brackets.getModule("filesystem/FileSystem"),\n        PreferencesManager  = brackets.getModule("preferences/PreferencesManager"),\n        NodeDomain          = brackets.getModule("utils/NodeDomain"),\n        ProjectManager      = brackets.getModule("project/ProjectManager");\n    \n    // Boilerplate to load NodeDomain\n    var _domainPath = ExtensionUtils.getModulePath(module, "node/2.0.3/SASSDomain"),\n        _nodeDomain = new NodeDomain("sass-v2.0.3", _domainPath);\n    \n    // Initialize temp folder on windows only\n    // This is to normalize windows paths instead of using Node\'s os.tmpdir()\n    // which usually resolves to C:\\Users\\name~1\\..., getApplicationSupportDirectory\n    // will resolve to C:\\Users\\name_000 instead which is more compatible\n    // with Brackets\' FileSystem paths\n    if (brackets.platform === "win") {\n        _nodeDomain.exec("setTempDir", brackets.app.getApplicationSupportDirectory()).fail(function (err) {\n            console.error("Failed creating brackets-sass temporary directory: " + err);\n        });\n    }\n    \n    var RE_FILE_EXT     = /\\.(sass|scss)$/,\n        PREF_ENABLED    = "enabled",\n        PREF_COMPILER   = "compiler",\n        PREF_COMPASS    = "compass",\n        PREF_TIMEOUT    = "timeout",\n        PREF_OPTIONS    = "options";\n\n    var extensionPrefs = PreferencesManager.getExtensionPrefs("sass"),\n        scannedFileMap = {},\n        partialErrorMap = {};\n\n    // Normalize a path (e.g. a/b/../c becomes a/c)\n    function _normalizePath(path) {\n        var up = 0,\n            i,\n            parts = path.split("/").filter(function (part, index) {\n                return !!part;\n            });\n\n        for (i = parts.length - 1; i >= 0; i--) {\n            var last = parts[i];\n            if (last === ".") {\n                parts.splice(i, 1);\n            } else if (last === "..") {\n                parts.splice(i, 1);\n                up++;\n            } else if (up) {\n                parts.splice(i, 1);\n                up--;\n            }\n        }\n        while (up--) {\n            parts.unshift("..");\n        }\n\n        return parts.join("/");\n    }\n\n    function _fixSourceMapPaths(json, css, prefs) {\n        var inputFile = prefs.inputFile,\n            cssFilePath = prefs.outputCSSFile.fullPath,\n            sourceMapFilePath = prefs.outputSourceMapFile.fullPath;\n\n        // Replace backslashes in paths\n        json.sources = json.sources.map(function (source) {\n            return source.replace(/\\\\/g, "/");\n        });\n\n        // Output CSS file should be relative to the source map\n        if (typeof prefs.options.sourceMap === "string") {\n            json.file = PathUtils.makePathRelative(cssFilePath, sourceMapFilePath);\n\n            if (prefs.compiler === "ruby") {\n                var sourcesPrefix = PathUtils.makePathRelative(PathUtils.directory(cssFilePath), PathUtils.directory(sourceMapFilePath)),\n                    mapPrefix = PathUtils.makePathRelative(PathUtils.directory(sourceMapFilePath), PathUtils.directory(cssFilePath));\n\n                json.sources = json.sources.map(function (source) {\n                    return _normalizePath(sourcesPrefix + source);\n                });\n\n                css = css.replace(/\\/\\*# sourceMappingURL=(.*?) \\*\\//, function (_, url) {\n                    return "/*# sourceMappingUrl=" + _normalizePath(mapPrefix + url) + " */";\n                });\n            }\n        }\n\n        // For some reason, sources are output relative to the CWD\n        // Add a sourceRoot to fix\n        // json.sourceRoot = PathUtils.makePathRelative(inputFile.parentPath, sourceMapFilePath);\n\n        // TODO read tab/space preference?\n        return {\n            map: JSON.stringify(json, null, "  "),\n            css: css\n        };\n    }\n    \n    function _render(path, prefs) {\n        var deferred = new $.Deferred(),\n            options = prefs.options;\n        \n        var renderPromise = _nodeDomain.exec("render",\n            path,\n            prefs.outputCSSFile.fullPath,\n            options.includePaths,\n            options.imagePath,\n            options.outputStyle,\n            options.sourceComments,\n            prefs.outputSourceMapFile.fullPath,\n            prefs.compiler,\n            prefs.compass);\n\n        renderPromise.then(function (response) {\n            var result = _fixSourceMapPaths(response.map, response.css, prefs);\n            deferred.resolve(result.css, result.map, response.error, response._compassOutFile);\n        }, deferred.reject);\n        \n        return deferred.promise();\n    }\n\n    function _getPreferencesForFile(file) {\n        var prefs = extensionPrefs,\n            enabled = prefs.get(PREF_ENABLED, { path: file.fullPath }),\n            compiler = prefs.get(PREF_COMPILER, { path: file.fullPath }) || "libsass",\n            compass = !!prefs.get(PREF_COMPASS, { path: file.fullPath }),\n            options = prefs.get(PREF_OPTIONS, { path: file.fullPath }),\n            outputName = (options && options.output) || file.name.replace(RE_FILE_EXT, ".css"),\n            outputDir = (options && options.outputDir),\n            parentPath = file.parentPath,\n            sourceMapPath,\n            outputFile;\n\n        if (outputDir) {\n            if (outputDir.charAt(outputDir.length - 1) !== "/") {\n                outputDir = outputDir + "/";\n            }\n\n            if (FileSystem.isAbsolutePath(outputDir)) {\n                parentPath = outputDir;\n            } else {\n                parentPath = FileSystem.getDirectoryForPath(parentPath + outputDir).fullPath;\n            }\n        }\n\n        outputFile = FileSystem.getFileForPath(parentPath + outputName);\n\n        options = _.defaults(options || {}, {\n            outputStyle: "nested",\n            sourceComments: true,\n            sourceMap: true\n        });\n\n        // Initialize sourceMap with full path\n        if (typeof options.sourceMap === "string") {\n            options.sourceMap = outputFile.parentPath + options.sourceMap;\n            sourceMapPath = options.sourceMap;\n        } else {\n            sourceMapPath = outputFile.parentPath + outputFile.name + ".map";\n        }\n        \n        return {\n            enabled: enabled,\n            compiler: compiler,\n            compass: compass ? { projectRoot: ProjectManager.getProjectRoot().fullPath } : false,\n            options: options,\n            inputFile: file,\n            outputCSSFile: outputFile,\n            outputSourceMapFile: FileSystem.getFileForPath(sourceMapPath)\n        };\n    }\n    \n    function _deferredForScannedPath(path, doAbort) {\n        var deferred = scannedFileMap[path];\n        \n        if (deferred && doAbort) {\n            // Abort current scan\n            deferred.resolve({\n                errors: [],\n                aborted: true\n            });\n\n            deferred = null;\n        }\n        \n        if (!deferred) {\n            deferred = new $.Deferred();\n            scannedFileMap[path] = deferred;\n        }\n        \n        return deferred;\n    }\n    \n    function getErrors(path) {\n        return _deferredForScannedPath(path, true).promise();\n    }\n    \n    function _getInMemoryFiles(docs) {\n        var map = {};\n        \n        _.each(docs, function (doc) {\n            if (doc.isDirty) {\n                map[doc.file.fullPath] = doc.getText();\n            }\n        });\n        \n        return map;\n    }\n    \n    function _finishScan(file, errors) {\n        var path = file.fullPath,\n            prefs = _getPreferencesForFile(file),\n            sassFileExtension = FileUtils.getFileExtension(path),\n            scanDeferred = _deferredForScannedPath(path);\n\n        // Clear cached errors\n        partialErrorMap = {};\n\n        var result = {\n            errors: [],\n            aborted: false\n        };\n\n        errors = errors || [];\n        errors = Array.isArray(errors) ? errors : [errors];\n\n        if (prefs.compiler !== "ruby" && prefs.compass) {\n            result.errors.push({\n                message: "Libsass doesn\'t support Compass yet: something may not work. You should use the Ruby Sass compiler.",\n                pos: {\n                    line: undefined\n                }\n            });\n        }\n\n        _.each(errors, function (err) {\n            if (err && err.path) {\n                err.path = FileUtils.convertWindowsPathToUnixPath(err.path);\n            }\n            \n            if (typeof err === "string") {\n                err = {\n                    message: err,\n                    pos: {\n                        line: -1\n                    }\n                };\n            } else if (path !== err.path) {\n                // Can\'t report errors on files other than the current document, see CodeInspection\n                // Clone error\n                var clonedError = _.clone(err);\n                clonedError.pos = _.clone(err.pos);\n\n                partialErrorMap[err.path] = partialErrorMap[err.path] || [];\n                partialErrorMap[err.path].push(clonedError);\n\n                // Omit position if the file path doesn\'t match\n                err.pos.line = undefined;\n\n                // HACK Add path to error message\n                err.message = err.path + " - " + err.message;\n            }\n\n            err.type = CodeInspection.Type.ERROR;\n            result.errors.push(err);\n        });\n\n        scanDeferred.resolve(result);\n\n        // Resolve promises for partials\n        _.each(scannedFileMap, function (deferred, partialPath) {\n            // Only deal with pending files\n            if (deferred.state() !== "pending") {\n                return;\n            }\n            \n            deferred.resolve({\n                errors: partialErrorMap[partialPath] || [],\n                aborted: false\n            });\n        });\n    }\n    \n    function _mkdirp(path) {\n        return _nodeDomain.exec("mkdirp", path);\n    }\n    \n    function compile(sassFile) {\n        var prefs = _getPreferencesForFile(sassFile);\n\n        if (!prefs.enabled) {\n            return new $.Deferred().reject().promise();\n        }\n\n        var cssFile = prefs.outputCSSFile,\n            mapFile = prefs.outputSourceMapFile,\n            renderPromise;\n        \n        renderPromise = _render(sassFile.fullPath, prefs);\n        \n        StatusBarUtil.showBusyStatus("Compiling " + PathUtils.makePathRelative(sassFile.fullPath, ProjectManager.getProjectRoot().fullPath));\n        \n        return renderPromise.then(function (css, map, error, _compassOutFile) {\n            // HACK deal with compass output\n            if (_compassOutFile) {\n                _compassOutFile = FileUtils.convertWindowsPathToUnixPath(_compassOutFile);\n                cssFile = FileSystem.getFileForPath(_compassOutFile);\n                mapFile = FileSystem.getFileForPath(_compassOutFile + ".map");\n            }\n\n            var eventData = {\n                    css: {\n                        file: cssFile,\n                        contents: css\n                    }\n                };\n            \n            _mkdirp(cssFile.parentPath).done(function () {\n                FileUtils.writeText(cssFile, css, true);\n            });\n            \n            if (map) {\n                _mkdirp(mapFile.parentPath).done(function () {\n                    FileUtils.writeText(mapFile, map, true);\n                \n                    eventData.sourceMap = {\n                        file: mapFile,\n                        contents: map\n                    };\n                });\n            }\n            \n            _finishScan(sassFile, error);\n        }, function (errors) {\n            _finishScan(sassFile, errors);\n        }).always(function () {\n            StatusBarUtil.hideBusyStatus();\n        });\n    }\n    \n    function preview(sassFile, docs) {\n        var deferred = new $.Deferred(),\n            prefs = _getPreferencesForFile(sassFile);\n        \n        // TODO warnings for compass that live preview isn\'t supported yet\n        // TODO support compiler errors with compass\n        // Requires changes to config.rb?\n        if (prefs.compass) {\n            _finishScan(sassFile, []);\n            return deferred.resolve().promise();\n        }\n        \n        var cssFile = prefs.outputCSSFile,\n            mapFile = prefs.outputSourceMapFile,\n            options = prefs.options,\n            previewPromise,\n            inMemoryFiles = _getInMemoryFiles(docs),\n            compass = prefs.compass;\n        \n        $(exports).triggerHandler("sourceMapPreviewStart", [sassFile, cssFile]);\n        \n        previewPromise = _nodeDomain.exec("preview",\n            sassFile.fullPath,\n            prefs.outputCSSFile.fullPath,\n            inMemoryFiles,\n            options.includePaths,\n            options.imagePath,\n            options.outputStyle,\n            "map",\n            prefs.outputSourceMapFile.fullPath,\n            prefs.compiler,\n            prefs.compass);\n        \n        StatusBarUtil.showBusyStatus("Checking for errors");\n        \n        previewPromise.then(function (response) {\n            var result = _fixSourceMapPaths(response.map, response.css, prefs),\n                eventData = {\n                    css: {\n                        file: cssFile,\n                        contents: result.css\n                    },\n                    sourceMap: {\n                        file: mapFile,\n                        contents: result.json\n                    }\n                };\n\n            $(exports).triggerHandler("sourceMapPreviewEnd", [sassFile, eventData]);\n            _finishScan(sassFile, response.error);\n            \n            deferred.resolve(response.css, response.map);\n        }, function (errors) {\n            $(exports).triggerHandler("sourceMapPreviewError", [sassFile, cssFile, errors]);\n            _finishScan(sassFile, errors);\n            \n            deferred.reject(errors);\n        }).always(function () {\n            StatusBarUtil.hideBusyStatus();\n        });\n        \n        return deferred.promise();\n    }\n\n    function deleteTempFiles() {\n        return _nodeDomain.exec("deleteTempFiles");\n    }\n\n    function _prefChangeHandler(event) {\n        // TODO compile all files?\n        // _compileWithPreferences();\n        _nodeDomain.exec("setCompilerTimeout", extensionPrefs.get(PREF_TIMEOUT));\n    }\n\n    function killProcess() {\n        _nodeDomain.exec("killProcess");\n    }\n     \n    // Register preferences\n    extensionPrefs.definePreference(PREF_ENABLED, "boolean", true)\n        .on("change", _prefChangeHandler);\n    \n    extensionPrefs.definePreference(PREF_OPTIONS, "object")\n        .on("change", _prefChangeHandler);\n    \n    extensionPrefs.definePreference(PREF_COMPILER, "string", "libsass")\n        .on("change", _prefChangeHandler);\n\n    extensionPrefs.definePreference(PREF_COMPASS, "boolean", false)\n        .on("change", _prefChangeHandler);\n\n    extensionPrefs.definePreference(PREF_TIMEOUT, "number", -1)\n        .on("change", _prefChangeHandler);\n    \n    _prefChangeHandler();\n\n    // Public API\n    exports.compile = compile;\n    exports.preview = preview;\n    exports.deleteTempFiles = deleteTempFiles;\n    exports.getErrors = getErrors;\n    exports.killProcess = killProcess;\n});\n//# sourceURL=/Compiler.js'),eval('/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n * \n */\n\n\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, regexp: true */\n/*global brackets, define, $, _parseRuleList: true */\n\n// JSLint Note: _parseRuleList() is cyclical dependency, not a global function.\n// It was added to this list to prevent JSLint warning about being used before being defined.\n\n/**\n * Set of utilities for simple parsing of CSS text.\n */\ndefine(\'NestedStyleParser\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\n    "use strict";\n    \n    var CodeMirror = brackets.getModule("thirdparty/CodeMirror2/lib/codemirror");\n\n    /**\n     * Extracts all CSS selectors from the given text\n     * Returns an array of selectors. Each selector is an object with the following properties:\n         selector:                 the text of the selector (note: comma separated selector groups like \n                                   "h1, h2" are broken into separate selectors)\n         ruleStartLine:            line in the text where the rule (including preceding comment) appears\n         ruleStartChar:            column in the line where the rule (including preceding comment) starts\n         selectorStartLine:        line in the text where the selector appears\n         selectorStartChar:        column in the line where the selector starts\n         selectorEndLine:          line where the selector ends\n         selectorEndChar:          column where the selector ends\n         selectorGroupStartLine:   line where the comma-separated selector group (e.g. .foo, .bar, .baz)\n                                   starts that this selector (e.g. .baz) is part of. Particularly relevant for\n                                   groups that are on multiple lines.\n         selectorGroupStartChar:   column in line where the selector group starts.\n         selectorGroup:            the entire selector group containing this selector, or undefined if there \n                                   is only one selector in the rule.\n         declListStartLine:        line where the declaration list for the rule starts\n         declListStartChar:        column in line where the declaration list for the rule starts\n         declListEndLine:          line where the declaration list for the rule ends\n         declListEndChar:          column in the line where the declaration list for the rule ends\n     * @param text {!string} CSS text to extract from\n     * @return {Array.<Object>} Array with objects specifying selectors.\n     */\n    function extractAllSelectors(text) {\n        var selectors = [];\n        var mode = CodeMirror.getMode({indentUnit: 2}, "sass");\n        var state, lines, lineCount;\n        var token, style, stream, line;\n        var currentSelector = "";\n        var ruleStartChar = -1, ruleStartLine = -1;\n        var selectorStartChar = -1, selectorStartLine = -1;\n        var selectorGroupStartLine = -1, selectorGroupStartChar = -1;\n        var declListStartLine = -1, declListStartChar = -1;\n        var escapePattern = new RegExp("\\\\\\\\[^\\\\\\\\]+", "g");\n        var validationPattern = new RegExp("\\\\\\\\([a-f0-9]{6}|[a-f0-9]{4}(\\\\s|\\\\\\\\|$)|[a-f0-9]{2}(\\\\s|\\\\\\\\|$)|.)", "i");\n        \n        // implement _firstToken()/_nextToken() methods to\n        // provide a single stream of tokens\n        \n        function _hasStream() {\n            while (stream.eol()) {\n                line++;\n                if (line >= lineCount) {\n                    return false;\n                }\n                if (currentSelector.match(/\\S/)) {\n                    // If we are in a current selector and starting a newline,\n                    // make sure there is whitespace in the selector\n                    currentSelector += " ";\n                }\n                stream = new CodeMirror.StringStream(lines[line]);\n            }\n            return true;\n        }\n        \n        function _firstToken() {\n            state = CodeMirror.startState(mode);\n            lines = CodeMirror.splitLines(text);\n            lineCount = lines.length;\n            if (lineCount === 0) {\n                return false;\n            }\n            line = 0;\n            stream = new CodeMirror.StringStream(lines[line]);\n            if (!_hasStream()) {\n                return false;\n            }\n            style = mode.token(stream, state);\n            token = stream.current();\n            return true;\n        }\n        \n        function _nextToken() {\n            // advance the stream past this token\n            stream.start = stream.pos;\n            if (!_hasStream()) {\n                return false;\n            }\n            style = mode.token(stream, state);\n            token = stream.current();\n            return true;\n        }\n        \n        function _firstTokenSkippingWhitespace() {\n            if (!_firstToken()) {\n                return false;\n            }\n            while (!token.match(/\\S/)) {\n                if (!_nextToken()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        \n        function _nextTokenSkippingWhitespace() {\n            if (!_nextToken()) {\n                return false;\n            }\n            while (!token.match(/\\S/)) {\n                if (!_nextToken()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function _isStartComment() {\n            return (token.match(/^\\/\\*/));\n        }\n\n        function _isStartSingleLineComment() {\n            return (token.match(/^\\/\\//));\n        }\n        \n        function _parseComment() {\n            while (!token.match(/\\*\\/$/)) {\n                if (!_nextToken()) {\n                    break;\n                }\n            }\n        }\n\n        function _nextTokenSkippingComments() {\n            var isMultiLine = _isStartComment(),\n                isSingleLine = _isStartSingleLineComment();\n\n            if (!_nextToken()) {\n                return false;\n            }\n            while (isSingleLine || isMultiLine) {\n                if (isMultiLine) {\n                    _parseComment();\n                }/* else {\n                    stream.skipToEnd();\n                }*/\n                if (!_nextToken()) {\n                    return false;\n                }\n\n                isMultiLine = _isStartComment();\n                isSingleLine = _isStartSingleLineComment();\n            }\n            return true;\n        }\n\n        function _parseSelector(start) {\n            \n            currentSelector = "";\n            selectorStartChar = start;\n            selectorStartLine = line;\n            \n            // Everything until the next \',\' or \'{\' is part of the current selector\n            while (token !== "," && token !== "{") {\n                currentSelector += token;\n                if (!_nextTokenSkippingComments()) {\n                    return false; // eof\n                }\n            }\n            \n            // Unicode character replacement as defined in http://www.w3.org/TR/CSS21/syndata.html#characters\n            if (/\\\\/.test(currentSelector)) {\n                // Double replace in case of pattern overlapping (regex improvement?)\n                currentSelector = currentSelector.replace(escapePattern, function (escapedToken) {\n                    return escapedToken.replace(validationPattern, function (unicodeChar) {\n                        unicodeChar = unicodeChar.substr(1);\n                        if (unicodeChar.length === 1) {\n                            return unicodeChar;\n                        } else {\n                            if (parseInt(unicodeChar, 16) < 0x10FFFF) {\n                                return String.fromCharCode(parseInt(unicodeChar, 16));\n                            } else { return String.fromCharCode(0xFFFD); }\n                        }\n                    });\n                });\n            }\n            \n            currentSelector = currentSelector.trim();\n            var startChar = (selectorGroupStartLine === -1) ? selectorStartChar : selectorStartChar + 1;\n            var selectorStart = (stream.string.indexOf(currentSelector, selectorStartChar) !== -1) ? stream.string.indexOf(currentSelector, selectorStartChar - currentSelector.length) : startChar;\n\n            if (currentSelector !== "") {\n                selectors.push({selector: currentSelector,\n                                ruleStartLine: ruleStartLine,\n                                ruleStartChar: ruleStartChar,\n                                selectorStartLine: selectorStartLine,\n                                selectorStartChar: selectorStart,\n                                declListEndLine: -1,\n                                selectorEndLine: line,\n                                selectorEndChar: selectorStart + currentSelector.length,\n                                selectorGroupStartLine: selectorGroupStartLine,\n                                selectorGroupStartChar: selectorGroupStartChar\n                               });\n                currentSelector = "";\n            }\n            selectorStartChar = -1;\n\n            return true;\n        }\n        \n        function _parseSelectorList() {\n            selectorGroupStartLine = (stream.string.indexOf(",") !== -1) ? line : -1;\n            selectorGroupStartChar = stream.start;\n\n            if (!_parseSelector(stream.start)) {\n                return false;\n            }\n\n            while (token === ",") {\n                if (!_nextTokenSkippingComments()) {\n                    return false; // eof\n                }\n                if (!_parseSelector(stream.start)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function _parseDeclarationList() {\n\n            var j;\n            declListStartLine = Math.min(line, lineCount - 1);\n            declListStartChar = stream.start;\n            \n            // Extract the entire selector group we just saw.\n            var selectorGroup, sgLine;\n            if (selectorGroupStartLine !== -1) {\n                selectorGroup = "";\n                for (sgLine = selectorGroupStartLine; sgLine <= declListStartLine; sgLine++) {\n                    var startChar = 0, endChar = lines[sgLine].length;\n                    if (sgLine === selectorGroupStartLine) {\n                        startChar = selectorGroupStartChar;\n                    } else {\n                        selectorGroup += " "; // replace the newline with a single space\n                    }\n                    if (sgLine === declListStartLine) {\n                        endChar = declListStartChar;\n                    }\n                    selectorGroup += lines[sgLine].substring(startChar, endChar);\n                }\n                selectorGroup = selectorGroup.trim();\n            }\n\n            // Since we\'re now in a declaration list, that means we also finished\n            // parsing the whole selector group. Therefore, reset selectorGroupStartLine\n            // so that next time we parse a selector we know it\'s a new group\n            selectorGroupStartLine = -1;\n            selectorGroupStartChar = -1;\n            ruleStartLine = -1;\n            ruleStartChar = -1;\n\n            // Skip everything until the next \'}\'\n            while (token !== "}") {\n                if (!_nextTokenSkippingComments()) {\n                    break;\n                }\n            }\n            \n            // TODO support nested rules and parent selector "&"\n            // assign this declaration list position and selector group to every selector on the stack\n            // that doesn\'t have a declaration list start and end line\n            for (j = selectors.length - 1; j >= 0; j--) {\n                if (selectors[j].declListEndLine !== -1) {\n                    break;\n                } else {\n                    selectors[j].declListStartLine = declListStartLine;\n                    selectors[j].declListStartChar = declListStartChar;\n                    selectors[j].declListEndLine = line;\n                    selectors[j].declListEndChar = stream.pos - 1; // stream.pos actually points to the char after the }\n                    if (selectorGroup) {\n                        selectors[j].selectorGroup = selectorGroup;\n                    }\n                }\n            }\n        }\n        \n        function includeCommentInNextRule() {\n            if (ruleStartChar !== -1) {\n                return false;       // already included\n            }\n            if (stream.start > 0 && lines[line].substr(0, stream.start).indexOf("}") !== -1) {\n                return false;       // on same line as \'}\', so it\'s for previous rule\n            }\n            return true;\n        }\n        \n        function _isStartAtRule() {\n            return (token.match(/^@/));\n        }\n        \n        function _parseAtRule() {\n\n            // reset these fields to ignore comments preceding @rules\n            ruleStartLine = -1;\n            ruleStartChar = -1;\n            selectorStartLine = -1;\n            selectorStartChar = -1;\n            selectorGroupStartLine = -1;\n            selectorGroupStartChar = -1;\n            \n            if (token.match(/@media/i)) {\n                // @media rule holds a rule list\n                \n                // Skip everything until the opening \'{\'\n                while (token !== "{") {\n                    if (!_nextTokenSkippingComments()) {\n                        return; // eof\n                    }\n                }\n\n                // skip past \'{\', to next non-ws token\n                if (!_nextTokenSkippingWhitespace()) {\n                    return; // eof\n                }\n\n                // Parse rules until we see \'}\'\n                _parseRuleList("}");\n\n            } else if (token.match(/@(charset|import|namespace)/i)) {\n                \n                // This code handles @rules in this format:\n                //   @rule ... ;\n                // Skip everything until the next \';\'\n                while (token !== ";") {\n                    if (!_nextTokenSkippingComments()) {\n                        return; // eof\n                    }\n                }\n                \n            } else {\n                // This code handle @rules that use this format:\n                //    @rule ... { ... }\n                // such as @page, @keyframes (also -webkit-keyframes, etc.), and @font-face.\n                // Skip everything until the next \'}\'\n                while (token !== "}") {\n                    if (!_nextTokenSkippingComments()) {\n                        return; // eof\n                    }\n                }\n            }\n        }\n\n        // parse a style rule\n        function _parseRule() {\n            if (!_parseSelectorList()) {\n                return false;\n            }\n\n            _parseDeclarationList();\n        }\n        \n        function _parseRuleList(escapeToken) {\n            \n            while ((!escapeToken) || token !== escapeToken) {\n                if (_isStartAtRule()) {\n                    // @rule\n                    _parseAtRule();\n    \n                } else if (_isStartComment()) {\n                    // comment - make this part of style rule\n                    if (includeCommentInNextRule()) {\n                        ruleStartChar = stream.start;\n                        ruleStartLine = line;\n                    }\n                    _parseComment();\n                \n                } else if (_isStartSingleLineComment()) {\n                    // comment - make this part of style rule\n                    if (includeCommentInNextRule()) {\n                        ruleStartChar = stream.start;\n                        ruleStartLine = line;\n                    }\n                } else {\n                    // Otherwise, it\'s style rule\n                    if (ruleStartChar === -1) {\n                        ruleStartChar = stream.start;\n                        ruleStartLine = line;\n                    }\n                    _parseRule();\n                }\n                \n                if (!_nextTokenSkippingWhitespace()) {\n                    break;\n                }\n            }\n        }\n        \n        // Do parsing\n\n        if (_firstTokenSkippingWhitespace()) {\n\n            // Style sheet is a rule list\n            _parseRuleList();\n        }\n\n        return selectors;\n    }\n    \n    exports.extractAllSelectors = extractAllSelectors;\n});\n\n//# sourceURL=/NestedStyleParser.js'),eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine('thirdparty/source-map/lib/source-map/util',['require','exports','module'],function (require, exports, module) {\n\n  /**\n   * This is a helper function for getting values from parameter/options\n   * objects.\n   *\n   * @param args The object we are extracting values from\n   * @param name The name of the property we are getting.\n   * @param defaultValue An optional value to return if the property is missing\n   * from the object. If this is not specified and the property is missing, an\n   * error will be thrown.\n   */\n  function getArg(aArgs, aName, aDefaultValue) {\n    if (aName in aArgs) {\n      return aArgs[aName];\n    } else if (arguments.length === 3) {\n      return aDefaultValue;\n    } else {\n      throw new Error('\"' + aName + '\" is a required argument.');\n    }\n  }\n  exports.getArg = getArg;\n\n  var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n  var dataUrlRegexp = /^data:.+\\,.+$/;\n\n  function urlParse(aUrl) {\n    var match = aUrl.match(urlRegexp);\n    if (!match) {\n      return null;\n    }\n    return {\n      scheme: match[1],\n      auth: match[2],\n      host: match[3],\n      port: match[4],\n      path: match[5]\n    };\n  }\n  exports.urlParse = urlParse;\n\n  function urlGenerate(aParsedUrl) {\n    var url = '';\n    if (aParsedUrl.scheme) {\n      url += aParsedUrl.scheme + ':';\n    }\n    url += '//';\n    if (aParsedUrl.auth) {\n      url += aParsedUrl.auth + '@';\n    }\n    if (aParsedUrl.host) {\n      url += aParsedUrl.host;\n    }\n    if (aParsedUrl.port) {\n      url += \":\" + aParsedUrl.port\n    }\n    if (aParsedUrl.path) {\n      url += aParsedUrl.path;\n    }\n    return url;\n  }\n  exports.urlGenerate = urlGenerate;\n\n  /**\n   * Normalizes a path, or the path portion of a URL:\n   *\n   * - Replaces consequtive slashes with one slash.\n   * - Removes unnecessary '.' parts.\n   * - Removes unnecessary '<dir>/..' parts.\n   *\n   * Based on code in the Node.js 'path' core module.\n   *\n   * @param aPath The path or url to normalize.\n   */\n  function normalize(aPath) {\n    var path = aPath;\n    var url = urlParse(aPath);\n    if (url) {\n      if (!url.path) {\n        return aPath;\n      }\n      path = url.path;\n    }\n    var isAbsolute = (path.charAt(0) === '/');\n\n    var parts = path.split(/\\/+/);\n    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n      part = parts[i];\n      if (part === '.') {\n        parts.splice(i, 1);\n      } else if (part === '..') {\n        up++;\n      } else if (up > 0) {\n        if (part === '') {\n          // The first part is blank if the path is absolute. Trying to go\n          // above the root is a no-op. Therefore we can remove all '..' parts\n          // directly after the root.\n          parts.splice(i + 1, up);\n          up = 0;\n        } else {\n          parts.splice(i, 2);\n          up--;\n        }\n      }\n    }\n    path = parts.join('/');\n\n    if (path === '') {\n      path = isAbsolute ? '/' : '.';\n    }\n\n    if (url) {\n      url.path = path;\n      return urlGenerate(url);\n    }\n    return path;\n  }\n  exports.normalize = normalize;\n\n  /**\n   * Joins two paths/URLs.\n   *\n   * @param aRoot The root path or URL.\n   * @param aPath The path or URL to be joined with the root.\n   *\n   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n   *   first.\n   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n   *   is updated with the result and aRoot is returned. Otherwise the result\n   *   is returned.\n   *   - If aPath is absolute, the result is aPath.\n   *   - Otherwise the two paths are joined with a slash.\n   * - Joining for example 'http://' and 'www.example.com' is also supported.\n   */\n  function join(aRoot, aPath) {\n    var aPathUrl = urlParse(aPath);\n    var aRootUrl = urlParse(aRoot);\n    if (aRootUrl) {\n      aRoot = aRootUrl.path || '/';\n    }\n\n    // `join(foo, '//www.example.org')`\n    if (aPathUrl && !aPathUrl.scheme) {\n      if (aRootUrl) {\n        aPathUrl.scheme = aRootUrl.scheme;\n      }\n      return urlGenerate(aPathUrl);\n    }\n\n    if (aPathUrl || aPath.match(dataUrlRegexp)) {\n      return aPath;\n    }\n\n    // `join('http://', 'www.example.com')`\n    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n      aRootUrl.host = aPath;\n      return urlGenerate(aRootUrl);\n    }\n\n    var joined = aPath.charAt(0) === '/'\n      ? aPath\n      : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n    if (aRootUrl) {\n      aRootUrl.path = joined;\n      return urlGenerate(aRootUrl);\n    }\n    return joined;\n  }\n  exports.join = join;\n\n  /**\n   * Because behavior goes wacky when you set `__proto__` on objects, we\n   * have to prefix all the strings in our set with an arbitrary character.\n   *\n   * See https://github.com/mozilla/source-map/pull/31 and\n   * https://github.com/mozilla/source-map/issues/30\n   *\n   * @param String aStr\n   */\n  function toSetString(aStr) {\n    return '$' + aStr;\n  }\n  exports.toSetString = toSetString;\n\n  function fromSetString(aStr) {\n    return aStr.substr(1);\n  }\n  exports.fromSetString = fromSetString;\n\n  function relative(aRoot, aPath) {\n    aRoot = aRoot.replace(/\\/$/, '');\n\n    var url = urlParse(aRoot);\n    if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {\n      return aPath.slice(1);\n    }\n\n    return aPath.indexOf(aRoot + '/') === 0\n      ? aPath.substr(aRoot.length + 1)\n      : aPath;\n  }\n  exports.relative = relative;\n\n  function strcmp(aStr1, aStr2) {\n    var s1 = aStr1 || \"\";\n    var s2 = aStr2 || \"\";\n    return (s1 > s2) - (s1 < s2);\n  }\n\n  /**\n   * Comparator between two mappings where the original positions are compared.\n   *\n   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n   * mappings with the same original source/line/column, but different generated\n   * line and column the same. Useful when searching for a mapping with a\n   * stubbed out mapping.\n   */\n  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp;\n\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp || onlyCompareOriginal) {\n      return cmp;\n    }\n\n    cmp = strcmp(mappingA.name, mappingB.name);\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    return mappingA.generatedColumn - mappingB.generatedColumn;\n  };\n  exports.compareByOriginalPositions = compareByOriginalPositions;\n\n  /**\n   * Comparator between two mappings where the generated positions are\n   * compared.\n   *\n   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n   * mappings with the same generated line and column, but different\n   * source/name/original line and column the same. Useful when searching for a\n   * mapping with a stubbed out mapping.\n   */\n  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp;\n\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp || onlyCompareGenerated) {\n      return cmp;\n    }\n\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp) {\n      return cmp;\n    }\n\n    return strcmp(mappingA.name, mappingB.name);\n  };\n  exports.compareByGeneratedPositions = compareByGeneratedPositions;\n\n});\n\n//# sourceURL=/thirdparty/source-map/lib/source-map/util.js"),eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine('thirdparty/source-map/lib/source-map/binary-search',['require','exports','module'],function (require, exports, module) {\n\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the next\n    //      closest element that is less than that element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element which is less than the one we are searching for, so we\n    //      return null.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return aHaystack[mid];\n    }\n    else if (cmp > 0) {\n      // aHaystack[mid] is greater than our needle.\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);\n      }\n      // We did not find an exact match, return the next closest one\n      // (termination case 2).\n      return aHaystack[mid];\n    }\n    else {\n      // aHaystack[mid] is less than our needle.\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);\n      }\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (2) or (3) and return the appropriate thing.\n      return aLow < 0\n        ? null\n        : aHaystack[aLow];\n    }\n  }\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the next lowest value checked if there is no exact hit. This is because\n   * mappings between original and generated line/col pairs are single points,\n   * and there is an implicit region between each of them, so a miss just means\n   * that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare) {\n    return aHaystack.length > 0\n      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)\n      : null;\n  };\n\n});\n\n//# sourceURL=/thirdparty/source-map/lib/source-map/binary-search.js"),eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine('thirdparty/source-map/lib/source-map/array-set',['require','exports','module','./util'],function (require, exports, module) {\n\n  var util = require('./util');\n\n  /**\n   * A data structure which is a combination of an array and a set. Adding a new\n   * member is O(1), testing for membership is O(1), and finding the index of an\n   * element is O(1). Removing elements from the set is not supported. Only\n   * strings are supported for membership.\n   */\n  function ArraySet() {\n    this._array = [];\n    this._set = {};\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n    var set = new ArraySet();\n    for (var i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  };\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n    var isDuplicate = this.has(aStr);\n    var idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set[util.toSetString(aStr)] = idx;\n    }\n  };\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.has = function ArraySet_has(aStr) {\n    return Object.prototype.hasOwnProperty.call(this._set,\n                                                util.toSetString(aStr));\n  };\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n    if (this.has(aStr)) {\n      return this._set[util.toSetString(aStr)];\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  };\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  ArraySet.prototype.at = function ArraySet_at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error('No element indexed by ' + aIdx);\n  };\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  ArraySet.prototype.toArray = function ArraySet_toArray() {\n    return this._array.slice();\n  };\n\n  exports.ArraySet = ArraySet;\n\n});\n\n//# sourceURL=/thirdparty/source-map/lib/source-map/array-set.js"),eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine('thirdparty/source-map/lib/source-map/base64',['require','exports','module'],function (require, exports, module) {\n\n  var charToIntMap = {};\n  var intToCharMap = {};\n\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    .split('')\n    .forEach(function (ch, index) {\n      charToIntMap[ch] = index;\n      intToCharMap[index] = ch;\n    });\n\n  /**\n   * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n   */\n  exports.encode = function base64_encode(aNumber) {\n    if (aNumber in intToCharMap) {\n      return intToCharMap[aNumber];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + aNumber);\n  };\n\n  /**\n   * Decode a single base 64 digit to an integer.\n   */\n  exports.decode = function base64_decode(aChar) {\n    if (aChar in charToIntMap) {\n      return charToIntMap[aChar];\n    }\n    throw new TypeError(\"Not a valid base 64 digit: \" + aChar);\n  };\n\n});\n\n//# sourceURL=/thirdparty/source-map/lib/source-map/base64.js"),eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine('thirdparty/source-map/lib/source-map/base64-vlq',['require','exports','module','./base64'],function (require, exports, module) {\n\n  var base64 = require('./base64');\n\n  // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n  // length quantities we use in the source map spec, the first bit is the sign,\n  // the next four bits are the actual value, and the 6th bit is the\n  // continuation bit. The continuation bit tells us whether there are more\n  // digits in this value following this digit.\n  //\n  //   Continuation\n  //   |    Sign\n  //   |    |\n  //   V    V\n  //   101011\n\n  var VLQ_BASE_SHIFT = 5;\n\n  // binary: 100000\n  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n  // binary: 011111\n  var VLQ_BASE_MASK = VLQ_BASE - 1;\n\n  // binary: 100000\n  var VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n  /**\n   * Converts from a two-complement value to a value where the sign bit is\n   * is placed in the least significant bit.  For example, as decimals:\n   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n   */\n  function toVLQSigned(aValue) {\n    return aValue < 0\n      ? ((-aValue) << 1) + 1\n      : (aValue << 1) + 0;\n  }\n\n  /**\n   * Converts to a two-complement value from a value where the sign bit is\n   * is placed in the least significant bit.  For example, as decimals:\n   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n   */\n  function fromVLQSigned(aValue) {\n    var isNegative = (aValue & 1) === 1;\n    var shifted = aValue >> 1;\n    return isNegative\n      ? -shifted\n      : shifted;\n  }\n\n  /**\n   * Returns the base 64 VLQ encoded value.\n   */\n  exports.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n\n    var vlq = toVLQSigned(aValue);\n\n    do {\n      digit = vlq & VLQ_BASE_MASK;\n      vlq >>>= VLQ_BASE_SHIFT;\n      if (vlq > 0) {\n        // There are still more digits in this value, so we must make sure the\n        // continuation bit is marked.\n        digit |= VLQ_CONTINUATION_BIT;\n      }\n      encoded += base64.encode(digit);\n    } while (vlq > 0);\n\n    return encoded;\n  };\n\n  /**\n   * Decodes the next base 64 VLQ value from the given string and returns the\n   * value and the rest of the string.\n   */\n  exports.decode = function base64VLQ_decode(aStr) {\n    var i = 0;\n    var strLen = aStr.length;\n    var result = 0;\n    var shift = 0;\n    var continuation, digit;\n\n    do {\n      if (i >= strLen) {\n        throw new Error(\"Expected more digits in base 64 VLQ value.\");\n      }\n      digit = base64.decode(aStr.charAt(i++));\n      continuation = !!(digit & VLQ_CONTINUATION_BIT);\n      digit &= VLQ_BASE_MASK;\n      result = result + (digit << shift);\n      shift += VLQ_BASE_SHIFT;\n    } while (continuation);\n\n    return {\n      value: fromVLQSigned(result),\n      rest: aStr.slice(i)\n    };\n  };\n\n});\n\n//# sourceURL=/thirdparty/source-map/lib/source-map/base64-vlq.js"),eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine('thirdparty/source-map/lib/source-map/source-map-consumer',['require','exports','module','./util','./binary-search','./array-set','./base64-vlq'],function (require, exports, module) {\n\n  var util = require('./util');\n  var binarySearch = require('./binary-search');\n  var ArraySet = require('./array-set').ArraySet;\n  var base64VLQ = require('./base64-vlq');\n\n  /**\n   * A SourceMapConsumer instance represents a parsed source map which we can\n   * query for information about the original file positions by giving it a file\n   * position in the generated source.\n   *\n   * The only parameter is the raw source map (either as a JSON string, or\n   * already parsed to an object). According to the spec, source maps have the\n   * following attributes:\n   *\n   *   - version: Which version of the source map spec this map is following.\n   *   - sources: An array of URLs to the original source files.\n   *   - names: An array of identifiers which can be referrenced by individual mappings.\n   *   - sourceRoot: Optional. The URL root from which all sources are relative.\n   *   - sourcesContent: Optional. An array of contents of the original source files.\n   *   - mappings: A string of base64 VLQs which contain the actual mappings.\n   *   - file: Optional. The generated file this source map is associated with.\n   *\n   * Here is an example source map, taken from the source map spec[0]:\n   *\n   *     {\n   *       version : 3,\n   *       file: \"out.js\",\n   *       sourceRoot : \"\",\n   *       sources: [\"foo.js\", \"bar.js\"],\n   *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n   *       mappings: \"AA,AB;;ABCDE;\"\n   *     }\n   *\n   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n   */\n  function SourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    var version = util.getArg(sourceMap, 'version');\n    var sources = util.getArg(sourceMap, 'sources');\n    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n    // requires the array) to play nice here.\n    var names = util.getArg(sourceMap, 'names', []);\n    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n    var mappings = util.getArg(sourceMap, 'mappings');\n    var file = util.getArg(sourceMap, 'file', null);\n\n    // Once again, Sass deviates from the spec and supplies the version as a\n    // string rather than a number, so we use loose equality checking here.\n    if (version != this._version) {\n      throw new Error('Unsupported version: ' + version);\n    }\n\n    // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n    this._names = ArraySet.fromArray(names, true);\n    this._sources = ArraySet.fromArray(sources, true);\n\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this._mappings = mappings;\n    this.file = file;\n  }\n\n  /**\n   * Create a SourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @returns SourceMapConsumer\n   */\n  SourceMapConsumer.fromSourceMap =\n    function SourceMapConsumer_fromSourceMap(aSourceMap) {\n      var smc = Object.create(SourceMapConsumer.prototype);\n\n      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n      smc.sourceRoot = aSourceMap._sourceRoot;\n      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                              smc.sourceRoot);\n      smc.file = aSourceMap._file;\n\n      smc.__generatedMappings = aSourceMap._mappings.slice()\n        .sort(util.compareByGeneratedPositions);\n      smc.__originalMappings = aSourceMap._mappings.slice()\n        .sort(util.compareByOriginalPositions);\n\n      return smc;\n    };\n\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n  SourceMapConsumer.prototype._version = 3;\n\n  /**\n   * The list of original sources.\n   */\n  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {\n    get: function () {\n      return this._sources.toArray().map(function (s) {\n        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;\n      }, this);\n    }\n  });\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n\n  SourceMapConsumer.prototype.__generatedMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n    get: function () {\n      if (!this.__generatedMappings) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__generatedMappings;\n    }\n  });\n\n  SourceMapConsumer.prototype.__originalMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n    get: function () {\n      if (!this.__originalMappings) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__originalMappings;\n    }\n  });\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  SourceMapConsumer.prototype._parseMappings =\n    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      var generatedLine = 1;\n      var previousGeneratedColumn = 0;\n      var previousOriginalLine = 0;\n      var previousOriginalColumn = 0;\n      var previousSource = 0;\n      var previousName = 0;\n      var mappingSeparator = /^[,;]/;\n      var str = aStr;\n      var mapping;\n      var temp;\n\n      while (str.length > 0) {\n        if (str.charAt(0) === ';') {\n          generatedLine++;\n          str = str.slice(1);\n          previousGeneratedColumn = 0;\n        }\n        else if (str.charAt(0) === ',') {\n          str = str.slice(1);\n        }\n        else {\n          mapping = {};\n          mapping.generatedLine = generatedLine;\n\n          // Generated column.\n          temp = base64VLQ.decode(str);\n          mapping.generatedColumn = previousGeneratedColumn + temp.value;\n          previousGeneratedColumn = mapping.generatedColumn;\n          str = temp.rest;\n\n          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {\n            // Original source.\n            temp = base64VLQ.decode(str);\n            mapping.source = this._sources.at(previousSource + temp.value);\n            previousSource += temp.value;\n            str = temp.rest;\n            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {\n              throw new Error('Found a source, but no line and column');\n            }\n\n            // Original line.\n            temp = base64VLQ.decode(str);\n            mapping.originalLine = previousOriginalLine + temp.value;\n            previousOriginalLine = mapping.originalLine;\n            // Lines are stored 0-based\n            mapping.originalLine += 1;\n            str = temp.rest;\n            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {\n              throw new Error('Found a source and line, but no column');\n            }\n\n            // Original column.\n            temp = base64VLQ.decode(str);\n            mapping.originalColumn = previousOriginalColumn + temp.value;\n            previousOriginalColumn = mapping.originalColumn;\n            str = temp.rest;\n\n            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {\n              // Original name.\n              temp = base64VLQ.decode(str);\n              mapping.name = this._names.at(previousName + temp.value);\n              previousName += temp.value;\n              str = temp.rest;\n            }\n          }\n\n          this.__generatedMappings.push(mapping);\n          if (typeof mapping.originalLine === 'number') {\n            this.__originalMappings.push(mapping);\n          }\n        }\n      }\n\n      this.__generatedMappings.sort(util.compareByGeneratedPositions);\n      this.__originalMappings.sort(util.compareByOriginalPositions);\n    };\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  SourceMapConsumer.prototype._findMapping =\n    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                           aColumnName, aComparator) {\n      // To return the position we are searching for, we must first find the\n      // mapping for the given position and then return the opposite position it\n      // points to. Because the mappings are sorted, we can use binary search to\n      // find the best mapping.\n\n      if (aNeedle[aLineName] <= 0) {\n        throw new TypeError('Line must be greater than or equal to 1, got '\n                            + aNeedle[aLineName]);\n      }\n      if (aNeedle[aColumnName] < 0) {\n        throw new TypeError('Column must be greater than or equal to 0, got '\n                            + aNeedle[aColumnName]);\n      }\n\n      return binarySearch.search(aNeedle, aMappings, aComparator);\n    };\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.\n   *   - column: The column number in the generated source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.\n   *   - column: The column number in the original source, or null.\n   *   - name: The original identifier, or null.\n   */\n  SourceMapConsumer.prototype.originalPositionFor =\n    function SourceMapConsumer_originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n      };\n\n      var mapping = this._findMapping(needle,\n                                      this._generatedMappings,\n                                      \"generatedLine\",\n                                      \"generatedColumn\",\n                                      util.compareByGeneratedPositions);\n\n      if (mapping && mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source && this.sourceRoot) {\n          source = util.join(this.sourceRoot, source);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: util.getArg(mapping, 'name', null)\n        };\n      }\n\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    };\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * availible.\n   */\n  SourceMapConsumer.prototype.sourceContentFor =\n    function SourceMapConsumer_sourceContentFor(aSource) {\n      if (!this.sourcesContent) {\n        return null;\n      }\n\n      if (this.sourceRoot) {\n        aSource = util.relative(this.sourceRoot, aSource);\n      }\n\n      if (this._sources.has(aSource)) {\n        return this.sourcesContent[this._sources.indexOf(aSource)];\n      }\n\n      var url;\n      if (this.sourceRoot\n          && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\"\n            && this._sources.has(fileUriAbsPath)) {\n          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n        }\n\n        if ((!url.path || url.path == \"/\")\n            && this._sources.has(\"/\" + aSource)) {\n          return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n        }\n      }\n\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    };\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *   - column: The column number in the original source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  SourceMapConsumer.prototype.generatedPositionFor =\n    function SourceMapConsumer_generatedPositionFor(aArgs) {\n      var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: util.getArg(aArgs, 'column')\n      };\n\n      if (this.sourceRoot) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n\n      var mapping = this._findMapping(needle,\n                                      this._originalMappings,\n                                      \"originalLine\",\n                                      \"originalColumn\",\n                                      util.compareByOriginalPositions);\n\n      if (mapping) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null)\n        };\n      }\n\n      return {\n        line: null,\n        column: null\n      };\n    };\n\n  SourceMapConsumer.GENERATED_ORDER = 1;\n  SourceMapConsumer.ORIGINAL_ORDER = 2;\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  SourceMapConsumer.prototype.eachMapping =\n    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n      var mappings;\n      switch (order) {\n      case SourceMapConsumer.GENERATED_ORDER:\n        mappings = this._generatedMappings;\n        break;\n      case SourceMapConsumer.ORIGINAL_ORDER:\n        mappings = this._originalMappings;\n        break;\n      default:\n        throw new Error(\"Unknown order of iteration.\");\n      }\n\n      var sourceRoot = this.sourceRoot;\n      mappings.map(function (mapping) {\n        var source = mapping.source;\n        if (source && sourceRoot) {\n          source = util.join(sourceRoot, source);\n        }\n        return {\n          source: source,\n          generatedLine: mapping.generatedLine,\n          generatedColumn: mapping.generatedColumn,\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: mapping.name\n        };\n      }).forEach(aCallback, context);\n    };\n\n  exports.SourceMapConsumer = SourceMapConsumer;\n\n});\n\n//# sourceURL=/thirdparty/source-map/lib/source-map/source-map-consumer.js"),eval('/*\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n */\n/*jslint nomen:true, vars:true, regexp:true*/\n/*global window, console, define, brackets, $, Mustache, PathUtils*/\n\ndefine(\'SourceMapManager\',[\'require\',\'exports\',\'module\',\'thirdparty/source-map/lib/source-map/source-map-consumer\'],function (require, exports, module) {\n    "use strict";\n    \n    var SourceMapConsumer   = require("thirdparty/source-map/lib/source-map/source-map-consumer").SourceMapConsumer;\n    \n    // Load commonly used modules from Brackets\n    var _               = brackets.getModule("thirdparty/lodash"),\n        Async           = brackets.getModule("utils/Async"),\n        DocumentManager = brackets.getModule("document/DocumentManager"),\n        File            = brackets.getModule("filesystem/File"),\n        FileSystem      = brackets.getModule("filesystem/FileSystem"),\n        FileUtils       = brackets.getModule("file/FileUtils");\n    \n    var RE_SOURCE_MAPPING = /\\/\\*#\\s*sourceMappingURL=(.+)\\s+\\*\\//;\n    \n    function SourceMapManager() {\n        this._sourceMapDeferreds = {};\n        this._sourceMaps = {};\n        this._dependencyMap = {};\n    }\n    \n    /**\n     *\n     * @param {!File} file\n     */\n    SourceMapManager.prototype.deleteFile = function (file) {\n        delete this._sourceMapDeferreds[file.fullPath];\n        delete this._sourceMaps[file.fullPath];\n        delete this._dependencyMap[file.fullPath];\n    };\n    \n    /**\n     *\n     * @param {!File} cssFile\n     */\n    SourceMapManager.prototype.setSourceMapPending = function (cssFile) {\n        var self = this,\n            deferred = this._sourceMapDeferreds[cssFile.fullPath];\n        \n        // Only create a new promise if the existing one was resolved/rejected\n        if (!deferred || (deferred.state() !== "pending")) {\n            deferred = new $.Deferred();\n        }\n\n        deferred.done(function (sourceMap) {\n            self._sourceMaps[cssFile.fullPath] = sourceMap;\n        });\n        \n        this._sourceMapDeferreds[cssFile.fullPath] = deferred;\n    };\n    \n    /**\n     *\n     * @param {!File} cssFile\n     * @return {!$.Promise}\n     */\n    SourceMapManager.prototype.getSourceMap = function (cssFile) {\n        return this._sourceMapDeferreds[cssFile.fullPath];\n    };\n    \n    /**\n     *\n     * @param {!File} cssFile\n     * @return {!$.Promise}\n     */\n    SourceMapManager.prototype.getInputFile = function (cssFile) {\n        return this.getSourceMap(cssFile).then(function (sourceMap) {\n            return sourceMap.sassFile;\n        });\n    };\n    \n    /**\n     *\n     * @param {!File} cssFile\n     */\n    SourceMapManager.prototype.getSourceDocuments = function (cssFile) {\n        var deferred = new $.Deferred(),\n            sourceMapPromise = this.getSourceMap(cssFile),\n            docs = [],\n            docsPromise;\n        \n        sourceMapPromise.then(function (sourceMap) {\n            // Collect in-memory documents\n            docsPromise = Async.doInParallel(sourceMap._localSources, function (file) {\n                return DocumentManager.getDocumentForPath(file.fullPath).done(function (doc) {\n                    docs.push(doc);\n                });\n            });\n            \n            docsPromise.always(function () {\n                deferred.resolve(docs);\n            });\n        }, deferred.reject);\n        \n        return deferred.promise();\n    };\n    \n    /**\n     *\n     * @param {!File} cssFile\n     * @param {string} relPath\n     * @return {$.Promise}\n     */\n    SourceMapManager.prototype.getSourceDocument = function (cssFile, relPath) {\n        return DocumentManager.getDocumentForPath(cssFile.parentPath + relPath);\n    };\n    \n    /**\n     *\n     * @param {!string} text\n     */\n    SourceMapManager.prototype.getSourceMappingURL = function (text) {\n        var match = text.match(RE_SOURCE_MAPPING);\n\n        if (match) {\n            return match[1];\n        }\n\n        return null;\n    };\n    \n    /**\n     *\n     * @param {!File} cssFile\n     * @param {!(File|string)} sourceMapFile\n     */\n    SourceMapManager.prototype.setSourceMapFile = function (cssFile, sourceMapFile) {\n        this.setSourceMapPending(cssFile);\n\n        var self = this,\n            deferred = new $.Deferred(),\n            sourceMapFileResult = new $.Deferred();\n        \n        if (typeof sourceMapFile === "string") {\n            var sourceMapRelPath = sourceMapFile;\n            \n            // Change relative URLs to absolute\n            if (!PathUtils.isAbsoluteUrl(sourceMapRelPath)) {\n                sourceMapRelPath = cssFile.parentPath + sourceMapRelPath;\n            }\n            \n            // Resolve to a File\n            FileSystem.resolve(sourceMapRelPath, function (err, file) {\n                if (err) {\n                    sourceMapFileResult.reject(err);\n                } else {\n                    sourceMapFileResult.resolve(file);\n                }\n            });\n        } else if (sourceMapFile instanceof File) {\n            sourceMapFileResult.resolve(sourceMapFile);\n        }\n        \n        sourceMapFileResult.then(function (sourceMapFileResolved) {\n            // Read source map from disk\n            FileUtils.readAsText(sourceMapFileResolved).then(function (text) {\n                // Parse source map text\n                var sourceMap = self.setSourceMap(cssFile, sourceMapFileResolved, text);\n                deferred.resolve(sourceMap);\n            }, deferred.reject);\n        }, deferred.reject);\n        \n        return deferred.promise();\n    };\n    \n    /**\n     *\n     * @param {!File} cssFile\n     * @param {!File} mapFile\n     * @param {!string} mapText\n     * @param {?File} sassFile\n     */\n    SourceMapManager.prototype.setSourceMap = function (cssFile, mapFile, mapText, sassFile) {\n        this.setSourceMapPending(cssFile);\n\n        var self = this,\n            deferred = this._sourceMapDeferreds[cssFile.fullPath],\n            sourceMap,\n            localSources = [],\n            error;\n        \n        // Try to parse source map contents\n        try {\n            sourceMap = mapText && new SourceMapConsumer(mapText);\n        } catch (err) {\n            error = err;\n        }\n        \n        if (!sourceMap) {\n            // Resolve with previous source map if available\n            var prevSourceMap = this._sourceMaps[cssFile.fullPath];\n\n            if (prevSourceMap) {\n                deferred.resolve(prevSourceMap);\n            } else {\n                // Reject the promise if we fail to parse the source map\n                deferred.reject(error);\n            }\n            \n            return;\n        }\n        \n        // We always generate in-memory source maps to support editor features\n        // even when a user specifies that source maps should not be saved to\n        // disk. If a sourceMapFile is not provided, assume localSources paths\n        // are relative to the input cssFile.\n        var parentPath = (mapFile || cssFile).parentPath;\n\n        sourceMap.sources.forEach(function (source) {\n            // Gather the source document(s) that generated this CSS file\n            var localSourceFile = FileSystem.getFileForPath(parentPath + source),\n                dependencies = self._dependencyMap[localSourceFile.fullPath] || {};\n            \n            localSources.push(localSourceFile);\n            \n            // Map each source as a dependency for the input cssFile\n            self._dependencyMap[localSourceFile.fullPath] = dependencies;\n            self._dependencyMap[localSourceFile.fullPath][cssFile.fullPath] = {\n                cssFile: cssFile,\n                sourceMap: sourceMap\n            };\n        });\n        \n        // Set input SASS document\n        sourceMap.sassFile = sassFile || localSources[0];\n\n        // Swap generated file relative paths with local absolute paths\n        sourceMap._localSources = localSources;\n\n        if (!sourceMap.file && mapFile) {\n            sourceMap.file = mapFile.name.slice(0, -4);\n        }\n\n        // Set the output document (e.g. cmd line: sass input.scss output.css)\n        sourceMap.cssFile = cssFile || FileSystem.getFileForPath(sourceMap._mapFile.parentPath + sourceMap.file);\n        \n        // Resolve getSourceMap promise\n        deferred.resolve(sourceMap);\n        \n        return sourceMap;\n    };\n    \n    /**\n     * \n     * @param {!File} sassFile\n     * @return {Object.<string,{{cssFile: File, sourceMap: SourceMapConsumer}}>}\n     */\n    SourceMapManager.prototype.getUsageForFile = function (sassFile) {\n        return this._dependencyMap[sassFile.fullPath] || {};\n    };\n    \n    return new SourceMapManager();\n});\n\n//# sourceURL=/SourceMapManager.js'),eval('/*\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n */\n/*jslint nomen:true, vars:true*/\n/*global window, console, define, brackets, $, Mustache, PathUtils*/\n\ndefine(\'SASSAgent\',[\'require\',\'exports\',\'module\',\'Compiler\',\'SourceMapManager\'],function (require, exports, module) {\n    "use strict";\n    \n    var Compiler            = require("Compiler"),\n        SourceMapManager    = require("SourceMapManager");\n    \n    // Load commonly used modules from Brackets\n    var _               = brackets.getModule("thirdparty/lodash"),\n        Async           = brackets.getModule("utils/Async"),\n        DocumentManager = brackets.getModule("document/DocumentManager"),\n        FileSystem      = brackets.getModule("filesystem/FileSystem"),\n        FileUtils       = brackets.getModule("file/FileUtils"),\n        Inspector       = brackets.getModule("LiveDevelopment/Inspector/Inspector"),\n        LiveDevelopment = brackets.getModule("LiveDevelopment/LiveDevelopment");\n    \n    var server,\n        mapSourceURLs = {};\n    \n    function _setStatus(status, err) {\n        // HACK expose LiveDevelopment._setStatus()\n        LiveDevelopment.status = status;\n        window.$(LiveDevelopment).triggerHandler("statusChange", [status, err]);\n    }\n    \n    function _docChangeHandler(data) {\n        // Show out of sync while we wait for SASS to compile\n        _setStatus(LiveDevelopment.STATUS_OUT_OF_SYNC);\n\n        var sourceMapPromise = SourceMapManager.getSourceMap(data.cssFile);\n\n        sourceMapPromise.then(function (sourceMap) {\n            return Compiler.preview(sourceMap.sassFile, data.docs).then(function (css) {\n                Inspector.CSS.setStyleSheetText(data.header.styleSheetId, css);\n                \n                // TODO look for added/removed docs?\n                // FIXME This will clobber other status (e.g. HTML live preview)\n                _setStatus(LiveDevelopment.STATUS_ACTIVE);\n            });\n        }, function (err) {\n            // TODO show errors in gutter\n            console.log(err);\n\n            _setStatus(LiveDevelopment.STATUS_SYNC_ERROR);\n        });\n    }\n    \n    function _installSourceDocumentChangeHandlers(cssFile, sourceURL, header) {\n        var docs = [],\n            sourceMapPromise = SourceMapManager.getSourceMap(cssFile),\n            docsPromise;\n\n        docsPromise = sourceMapPromise.then(function (sourceMap) {\n            return Async.doInParallel(sourceMap._localSources, function (file) {\n                return DocumentManager.getDocumentForPath(file.fullPath).done(function (doc) {\n                    docs.push(doc);\n                });\n            });\n        });\n        \n        // Install change event handlers for source SCSS/SASS files\n        docsPromise.always(function () {\n            var data = {\n                cssFile: cssFile,\n                header: header,\n                docs: docs\n            };\n\n            var changeCallback = function (event, doc, res) {\n                _docChangeHandler(data);\n            };\n            \n            _.each(docs, function (doc) {\n                doc.addRef();\n                $(doc).on("change.sass", changeCallback);\n            });\n            \n            mapSourceURLs[sourceURL] = data;\n        });\n    }\n    \n    function _styleSheetAdded(event, sourceURL, header) {\n        var existing = mapSourceURLs[sourceURL];\n        \n        // detect duplicates\n        if (existing && existing.styleSheetId === header.styleSheetId) {\n            return;\n        }\n        \n        if (header.sourceMapURL) {\n            var cssPath = server.urlToPath(sourceURL),\n                cssFile = cssPath && FileSystem.getFileForPath(cssPath),\n                sourceMapURL = sourceURL.replace(new RegExp(PathUtils.parseUrl(sourceURL).filename + "$"), header.sourceMapURL),\n                sourceMapPath = server.urlToPath(sourceMapURL),\n                sourceMapFile = sourceMapPath && FileSystem.getFileForPath(sourceMapPath);\n            \n            SourceMapManager.setSourceMapFile(cssFile, sourceMapFile);\n            _installSourceDocumentChangeHandlers(cssFile, sourceURL, header);\n        }\n    }\n    \n    function _styleSheetRemoved(event, sourceURL) {\n        var data = mapSourceURLs[sourceURL];\n        \n        delete mapSourceURLs[sourceURL];\n        \n        if (!data) {\n            return;\n        }\n        \n        _.each(data.docs, function (doc) {\n            doc.releaseRef();\n            $(doc).off(".sass");\n        });\n    }\n    \n    function _statusChangeHandler(event, status, reason) {\n        var $CSSAgent = $(LiveDevelopment.agents.css);\n        \n        if (status <= LiveDevelopment.STATUS_INACTIVE) {\n            $CSSAgent.off(".sass");\n            \n            _.each(Object.keys(mapSourceURLs), function (sourceURL) {\n                _styleSheetRemoved(null, sourceURL);\n            });\n\n            Compiler.deleteTempFiles();\n            \n            server = null;\n        } else if (!server) {\n            $CSSAgent.on("styleSheetAdded.sass", _styleSheetAdded);\n            $CSSAgent.on("styleSheetRemoved.sass", _styleSheetRemoved);\n            \n            server = LiveDevelopment._getServer();\n        }\n    }\n    \n    $(LiveDevelopment).on("statusChange", _statusChangeHandler);\n});\n\n//# sourceURL=/SASSAgent.js'),eval('/*\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n *  \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"), \n * to deal in the Software without restriction, including without limitation \n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \n * and/or sell copies of the Software, and to permit persons to whom the \n * Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n * DEALINGS IN THE SOFTWARE.\n */\n/*jslint nomen:true, vars:true, regexp:true, plusplus: true*/\n/*global window, console, define, brackets, $, Mustache*/\n\ndefine(\'main\',[\'require\',\'exports\',\'module\',\'Compiler\',\'NestedStyleParser\',\'SASSAgent\',\'SourceMapManager\'],function (require, exports, module) {\n    "use strict";\n    \n    var Compiler          = require("Compiler"),\n        NestedStyleParser = require("NestedStyleParser"),\n        SASSAgent         = require("SASSAgent"),\n        SourceMapManager  = require("SourceMapManager");\n    \n    var _                 = brackets.getModule("thirdparty/lodash"),\n        AppInit           = brackets.getModule("utils/AppInit"),\n        Async             = brackets.getModule("utils/Async"),\n        CSSUtils          = brackets.getModule("language/CSSUtils"),\n        CodeInspection    = brackets.getModule("language/CodeInspection"),\n        DocumentManager   = brackets.getModule("document/DocumentManager"),\n        ExtensionManager  = brackets.getModule("extensibility/ExtensionManager"),\n        FileUtils         = brackets.getModule("file/FileUtils"),\n        FileSystem        = brackets.getModule("filesystem/FileSystem"),\n        ProjectManager    = brackets.getModule("project/ProjectManager");\n\n    // Distinguish input SASS files from partials\n    var RE_INPUT_FILE = /^[^_].*\\.(scss|sass)$/,\n        RE_PARTIAL_FILE = /^_.*\\.(scss|sass)$/;\n    \n    // Augment CSSUtils.findMatchingRules to support source maps\n    var baseFindMatchingRules = CSSUtils.findMatchingRules;\n    \n    function _convertMatchingRuleResult(selectorCache, generatedResult) {\n        // Check CSS text for a sourceMappingURL\n        var oneResult = new $.Deferred(),\n            cssFile = generatedResult.document.file,\n            sourceMapPromise = SourceMapManager.getSourceMap(cssFile),\n            match = !sourceMapPromise && SourceMapManager.getSourceMappingURL(generatedResult.document.getText());\n        \n        if (match) {\n            sourceMapPromise = SourceMapManager.setSourceMapFile(cssFile, match);\n        }\n\n        if (sourceMapPromise) {\n            sourceMapPromise.then(function (sourceMap) {\n                // TODO core brackets change to add selectorInfo \n                // generatedPos = { line: info.selectorStartLine + 1, column: info.selectorStartChar },\n                var info = generatedResult.selectorInfo,\n                    generatedPos = { line: generatedResult.lineStart + 1, column: 0 },\n                    origPos = sourceMap.originalPositionFor(generatedPos),\n                    newResult;\n                \n                SourceMapManager.getSourceDocument(cssFile, origPos.source).then(function (doc) {\n                    var fullPath = doc.file.fullPath,\n                        selectors = selectorCache[fullPath],\n                        fileExt = FileUtils.getFileExtension(fullPath),\n                        docText = doc.getText(),\n                        selector,\n                        origLine = origPos.line - 1,\n                        i;\n\n                    // HACK? Use CSSUtils to parse SCSS selectors\n                    if (!selectors) {\n                        if (fileExt === "scss") {\n                            selectors = NestedStyleParser.extractAllSelectors(docText);\n                        } else {\n                            // TODO support SASS\n                            // selectors = IndentedStyleParser.extractAllSelectors(docText);\n                            selectors = [];\n                        }\n\n                        selectorCache[doc.file.fullPath] = selectors;\n                    }\n\n                    // Find the original SASS selector based on the sourceMap position\n                    for (i = 0; i < selectors.length; i++) {\n                        selector = selectors[i];\n\n                        if ((origLine >= selector.ruleStartLine) && (origLine <= selector.selectorEndLine)) {\n                            break;\n                        } else if (origLine < selector.ruleStartLine) {\n                            // HACK We may skip over the actual rule/mixin due to our limited SASS parsing\n                            break;\n                        }\n                    }\n\n                    if (selector) {\n                        // CSSUtils can\'t handle single line \'//\' comments\n                        var name = selector.selector.replace("//.*\\n", "");\n                        \n                        newResult = {\n                            name: name,\n                            document: doc,\n                            lineStart: selector.ruleStartLine,\n                            lineEnd: selector.declListEndLine,\n                            selectorGroup: selector.selectorGroup\n                        };\n                    }\n\n                    // Overwrite original result\n                    if (newResult) {\n                        oneResult.resolve(newResult);\n                    } else {\n                        oneResult.reject();\n                    }\n                }, oneResult.reject);\n            }, function () {\n                // Source map error, use the original result\n                oneResult.reject();\n            });\n        } else {\n            // No source map for this result\n            oneResult.reject();\n        }\n\n        return oneResult.promise();\n    }\n    \n    /**\n     * Replace matched CSS rules with SASS rules\n     */\n    function findMatchingRules(selector, htmlDocument) {\n        var basePromise = baseFindMatchingRules(selector, htmlDocument),\n            deferred = new $.Deferred(),\n            newResults = [],\n            selectorCache = {};\n        \n        // Check CSS file results for an associated source map\n        basePromise.then(function (resultSelectors) {\n            var parallelPromise = Async.doInParallel(resultSelectors, function (resultSelector, index) {\n                var onePromise = _convertMatchingRuleResult(selectorCache, resultSelector);\n                \n                onePromise.then(function (newResult) {\n                    // Use new SASS results\n                    newResults[index] = newResult;\n                }, function () {\n                    // Use original result\n                    newResults[index] = resultSelector;\n                });\n                \n                return onePromise;\n            });\n            \n            parallelPromise.always(function () {\n                deferred.resolve(newResults);\n            });\n        }, deferred.reject);\n        \n        return deferred.promise();\n    }\n    \n    // TODO Reconcile this with new quick edit support for SCSS/LESS in Brackets 44\n    //      Can still provide value for SASS indented syntax\n    // CSSUtils.findMatchingRules = findMatchingRules;\n    \n    /**\n     * @private\n     * CodeInspection callback to provider SASS errors\n     * @param {!string} text\n     * @param {!path} path\n     */\n    function _scanFileAsync(text, path) {\n        // FIXME How to avoid calling preview() followed by compile()?\n        // CodeInspection runs first firing _scanFileAsync. For now,\n        // we just won\'t show errors when switching to a file that is not dirty\n        var fileToScan = FileSystem.getFileForPath(path),\n            usages = SourceMapManager.getUsageForFile(fileToScan),\n            docs,\n            inputFile = fileToScan,\n            deferred = new $.Deferred(),\n            usagePromise;\n        \n        if (_.size(usages) > 0) {\n            _.find(usages, function (usage) {\n                // Compile input SASS file (i.e. not partials) with in-memory document content\n                usagePromise = SourceMapManager.getSourceDocuments(usage.cssFile);\n                usagePromise.then(function (sourceDocs) {\n                    docs = sourceDocs;\n                    inputFile = usage.sourceMap.sassFile;\n                });\n                \n                // Compile first usage only\n                // FIXME support multiple usage?\n                return true;\n            });\n        } else {\n            docs = [];\n            usagePromise = new $.Deferred().resolve().promise();\n        }\n        \n        usagePromise.always(function () {\n            var errorPromise = Compiler.getErrors(path);\n            \n            // If the promise is resolved, errors were cached when the file was\n            // compiled as a partial.\n            if (errorPromise.state() === "pending") {\n                docs.unshift(DocumentManager.getOpenDocumentForPath(path));\n                Compiler.preview(inputFile, docs);\n            }\n            \n            errorPromise.done(function (result) {\n                deferred.resolve(result);\n            });\n        });\n        \n        return deferred.promise();\n    }\n\n    function _scanForSourceMaps() {\n        // Get all .css.map files\n        var promise = ProjectManager.getAllFiles(function (file) {\n            return file.name.match(/\\.css\\.map$/i) !== null;\n        });\n\n        // Convert .css.map paths to .css output paths\n        promise = promise.then(function (sourceMapFiles) {\n            return sourceMapFiles.map(function (sourceMapFile) {\n                // Get associated CSS file by dropping ".map"\n                return {\n                    sourceMapFile: sourceMapFile,\n                    cssFilePath: sourceMapFile.fullPath.replace(/\\.map$/i, "")\n                };\n            });\n        });\n\n        // Resolve css file paths to Files\n        var resolvedPairs = [];\n        promise = promise.then(function (pairs) {\n            return Async.doInParallel(pairs, function (pair) {\n                var deferred = new $.Deferred();\n\n                FileSystem.resolve(pair.cssFilePath, function (err, cssFile) {\n                    if (err) {\n                        deferred.reject();\n                    } else {\n                        pair.cssFile = cssFile;\n                        resolvedPairs.push(pair);\n                        deferred.resolve();\n                    }\n                });\n\n                return deferred.promise();\n            });\n        });\n\n        // Read .css file sourceMappingURL\n        promise.always(function () {\n            resolvedPairs.forEach(function (pair) {\n                var sourceMapFile = pair.sourceMapFile,\n                    cssFile = pair.cssFile;\n\n                FileUtils.readAsText(cssFile).done(function (cssText) {\n                    var sourceMapRelPath = SourceMapManager.getSourceMappingURL(cssText),\n                        regExp = new RegExp(sourceMapRelPath + "$");\n\n                    // Confirm CSS sourceMappingURL matches the source map path\n                    if (!sourceMapRelPath || !regExp.exec(sourceMapFile.fullPath)) {\n                        return;\n                    }\n\n                    SourceMapManager.setSourceMapFile(cssFile, sourceMapFile);\n                });\n            });\n        });\n    }\n\n    function _isSassFile(entry, regexp) {\n        var isFile = entry && entry.isFile && entry.name.match(regexp);\n\n        return isFile && ProjectManager.isWithinProject(entry);\n    }\n\n    function _isSassFileInput(entry) {\n        return _isSassFile(entry, RE_INPUT_FILE);\n    }\n\n    function _isSassFilePartial(entry) {\n        return _isSassFile(entry, RE_PARTIAL_FILE);\n    }\n\n    // Check if this file is referenced in one or more source maps\n    function _getUsageForFile(sassFile) {\n        var usages = SourceMapManager.getUsageForFile(sassFile),\n            inputFiles = [];\n\n        _.each(usages, function (usage) {\n            inputFiles.push(usage.sourceMap.sassFile);\n        });\n\n        return inputFiles;\n    }\n    \n    function _appReady() {\n        CodeInspection.register("scss", {\n            name: "SCSS",\n            scanFileAsync: _scanFileAsync\n        });\n\n        CodeInspection.register("sass", {\n            name: "SASS",\n            scanFileAsync: _scanFileAsync\n        });\n    }\n\n    $(ProjectManager).on("projectOpen", function (event, root) {\n        // TODO Reset SourceMapManager when project changes\n\n        // Scan for source maps in the new project\n        _scanForSourceMaps();\n    });\n    \n    // Return pending promises until preview completes\n    $(Compiler).on("sourceMapPreviewStart", function (event, sassFile, cssFile) {\n        if (_isSassFileInput(sassFile)) {\n            SourceMapManager.setSourceMapPending(cssFile);\n        }\n    });\n    \n    // Update source map when preview completes and resolve promise\n    $(Compiler).on("sourceMapPreviewEnd", function (event, sassFile, data) {\n        if (_isSassFileInput(sassFile)) {\n            SourceMapManager.setSourceMap(data.css.file, data.sourceMap.file, data.sourceMap.contents);\n        }\n    });\n    \n    // Reject promise waiting for a source map\n    $(Compiler).on("sourceMapPreviewError", function (event, sassFile, cssFile, errors) {\n        if (_isSassFileInput(sassFile)) {\n            SourceMapManager.setSourceMap(cssFile);\n        }\n    });\n    \n    // All SASS files get compiled when changed on disk\n    // TODO preferences to compile on demand, filter for file paths, etc.?\n    FileSystem.on("change", function (event, entry, added, removed) {\n        var filesToCompile = [],\n            findUsage = [];\n\n        if (entry) {\n            if (_isSassFileInput(entry)) {\n                // Compile a changed input file\n                filesToCompile.push(entry);\n                findUsage.push(entry);\n            } else if (_isSassFilePartial(entry)) {\n                // Check for usage of a partial file\n                findUsage.push(entry);\n            }\n        }\n\n        if (removed) {\n            removed.forEach(function (removedFile) {\n                // Find usages of partial files\n                if (_isSassFilePartial(removedFile)) {\n                    findUsage.push(removedFile);\n                }\n\n                // Clear caches\n                SourceMapManager.deleteFile(removedFile);\n            });\n        }\n\n        // Compile new input files (but not partials)\n        if (added) {\n            added.forEach(function (addedFile) {\n                if (_isSassFileInput(addedFile)) {\n                    filesToCompile.push(addedFile);\n                }\n            });\n        }\n\n        // Add input files that reference deleted/changed files\n        findUsage.forEach(function (sassFile) {\n            filesToCompile = filesToCompile.concat(_getUsageForFile(sassFile));\n        });\n        \n        // Re-compile\n        _.each(_.uniq(filesToCompile), function (entry) {\n            Compiler.compile(entry);\n        });\n    });\n    \n    ExtensionManager.on("statusChange", function (event, extensionId) {\n        if (extensionId === "jasonsanjose.brackets-sass" && (ExtensionManager.isMarkedForUpdate(extensionId) || ExtensionManager.isMarkedForRemoval(extensionId))) {\n            Compiler.killProcess();\n        }\n    });\n\n    // Delay initialization until `appReady` event is fired\n    AppInit.appReady(_appReady);\n});\n//# sourceURL=/main.js');

//# sourceMappingURL=main.js
//# sourceMappingURL=main.js.map